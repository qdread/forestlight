---
title: "More BCI plots with modeled light values"
author: "Quentin D. Read"
date: "June 27, 2017"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, message=FALSE, warning=FALSE, echo=FALSE}
fp <- 'C:/Users/Q/Dropbox/projects/forestlight/'

growth9095 <- read.delim(file.path(fp, 'BCI_light/growth_final9095.txt'), stringsAsFactors = FALSE)

# Load older census data.
#load(file.path(fp, 'bcidata/bci.full2.rdata')) # 1985
load(file.path(fp, 'bcidata/bci.full3.rdata')) # 1990
load(file.path(fp, 'bcidata/bci.full4.rdata')) # 1995

# Use 1990-1995 interval.
bci.full4$production34 <- pmax((bci.full4$agb - bci.full3$agb)/5, 0, na.rm = T)

library(dplyr)
library(cowplot)

bcicensusdat <- bci.full4 %>%
  filter(DFstatus == 'alive') %>%
  mutate(dbh = dbh/10,
         agb = agb * 1000,
         production34 = production34 * 1000)  # mm to cm and tonnes to kg

# Old code to join with the Wright tradeoff data.
library(XLConnect)
wright <- readWorksheetFromFile(file = 'C:/Users/Q/google_drive/ForestLight/data/Shade Tolerance/Demographic/Wright et al 2010, growth mortality tradeoffs.xlsx', sheet = 1, startRow = 26) # Get rid of the lines above header.
wright[wright == -99] <- NA # Unknown values were given a value of -99
wright$SPECIES.[109:110] <- c('simplex_var1', 'simplex_var2') # Correct duplicate named subspecies.
wright$Taxon <- with(wright, paste(GENUS., SPECIES.))

wright_df <- with(wright, data.frame(Taxon, mrt = MRT25SAP/100, rgr = RGR95SAP, stringsAsFactors = FALSE))
wright_df <- subset(wright_df, !is.na(mrt))

wright_pca <- with(wright_df, prcomp(data.frame(qlogis(mrt), log10(rgr)), scale=TRUE, center=TRUE)) # 90% of variation on the growth-mortality single axis. Nice.
pca_scores <- wright_pca$x[,1]
pca_groups <- cut(pca_scores, breaks = 3)
pca_groupcodes <- factor(pca_groups, labels = c('G','I','S'))

wright_df <- data.frame(wright_df, pca_scores, tol_wright = as.character(pca_groupcodes), stringsAsFactors = FALSE)

# Correct wright_df entries that are not correct.
wright_df$Taxon[grep('Beilsc',wright_df$Taxon)] <- 'Beilschmiedia pendula'
wright_df$Taxon[grep('Cestrum',wright_df$Taxon)] <- 'Cestrum megalophyllum'
wright_df$Taxon[grep('phyllu arg',wright_df$Taxon)] <- 'Chrysophyllum argenteum'
wright_df$Taxon[grep('Coccol',wright_df$Taxon)] <- 'Coccoloba manzinellensis'
wright_df$Taxon[grep('Tabern',wright_df$Taxon)] <- 'Tabernaemontana arborea'
wright_df$Taxon[grep('var1',wright_df$Taxon)] <- 'Swartzia simplex_var.grandiflora'
wright_df$Taxon[grep('var2',wright_df$Taxon)] <- 'Swartzia simplex_var.ochnacea'
wright_df$Taxon[grep('colorado',wright_df$Taxon)] <- 'Eugenia coloradoensis'
wright_df$Taxon[grep('Croton',wright_df$Taxon)] <- 'Croton billbergianus'

bci_lookup <- read.delim('C:/Users/Q/Dropbox/projects/forestlight/bcidata/ViewTax.txt', stringsAsFactors = FALSE)

bci_lookup <- bci_lookup %>%
  mutate(Taxon = paste(Genus, SpeciesName)) 

taxmatch <- bci_lookup$Taxon %in% wright_df$Taxon

bcicensusdat <- left_join(bci_lookup, wright_df) %>%
  rename(sp = Mnemonic) %>%
  select(sp, mrt, rgr, pca_scores, tol_wright) %>%
  right_join(bcicensusdat)

####################################################################

# Join bcicensusdat with Nadja's light values.

bcicensusdat <- bcicensusdat %>%
  mutate(tag = as.numeric(tag)) %>%
  left_join(growth9095 %>% dplyr::select(tag, light, dinc, interval))

# That was much easier than expected!
```


# I. Estimate total light received

We need to estimate the total light received by each tree to make the energy equivalence plot for light received to juxtapose with biomass produced. To do this, I used the allometric equation from Bohlman and O'Brien to get an estimate of the area of each crown as a horizontal disk, given diameter: $r_{crown} = e^{-0.438 + 0.658 \ln{d}}$, so $A_{crown} = \pi r_{crown}^2$. I multiplied this by the percent relative irradiance $p_{light}$. This quantity, $A_{crown}p_{light}$, gives a measure of the effective area in square meters of the crown receiving full light. In other words if the crown area is 10 square meters and the relative irradiance is 30%, that tree is getting an equivalent of 3 square meters of PAR. Then, I multiplied that by the average insolation of BCI (just a rough approximation to put the answer into correct units of W). The source of the approximation is "Analytical solution to a simple climate model with diffusive heat transport" (North 1975, J. Atmos. Sci.) It comes out to 418 $W/m^2$, a very rough value. The crude estimate of light energy received by each tree is thus $418A_{crown}p_{light}$, in units of W.

I grouped the trees into three groups, low, intermediate, and high light received, by the percentage of full light they received. So depending on the tree's crown area, two trees in the same group could have very different amounts of total energy received. Some of the figures below are based on these light groups.

```{r}

# Function to get a rough approximation of insolation by latitude.

insolation <- function(lat) {
  lat <- lat * pi/180 # to radians
  y <- sin(lat)
  0.25 * 1367 * (1 - 0.482 * (3*y^2 - 1)/2)
}

# Insolation at BCI, 9.2 degrees N
(insol_bci <- insolation(9.2))

# Function to get tree height and crown dimensions from dbh
# Use same parameters for all trees, taken from Bohlman and O'Brien

tp <- function(dbh) {
  h <- exp(.438 + .595 * log(dbh))    # Height
  cd <- exp(-.157 + .702 * log(dbh))  # Crown depth
  cr <- exp(-.438 + .658 * log(dbh))  # Crown radius
  cV <- exp(-.681 + 2.02 * log(dbh))  # Crown volume
  data.frame(h=h, cd=cd, cr=cr, cV=cV)
}

crowndim <- tp(bcicensusdat$dbh) 
bcicensusdat$crownarea <- pi * crowndim$cr^2
bcicensusdat <- transform(bcicensusdat, light_received = light * crownarea * insol_bci)

# Classification of light into 3 groups.
# This is percent of full irradiance, not the total light received.
light_groups <- cut(bcicensusdat$light, breaks = 3)
table(light_groups)
light_groupcodes <- factor(light_groups, 
                           labels = c('Low light','Intermediate light','High light'))

bcicensusdat$light_group <- light_groupcodes

alltreedat <- subset(bcicensusdat, 
                     !is.na(dbh) & production34 > 0 & !is.na(light))
shadedat <- subset(bcicensusdat, 
                   !is.na(dbh) & production34 > 0 & !is.na(light) & tol_wright == 'S')
intdat <- subset(bcicensusdat, 
                 !is.na(dbh) & production34 > 0 & !is.na(light) & tol_wright == 'I')
gapdat <- subset(bcicensusdat, 
                 !is.na(dbh) & production34 > 0 & !is.na(light) & tol_wright == 'G')


```

\newpage

# II. Plots of total energy received by shade-tolerance group

Compare these with the energy-equivalence plots (total production by shade-tolerance group). These should represent the inputs of energy per hectare to each size class within each shade-tolerance group. I also plotted it for the entire BCI plot. The three groups are on the same x- and y-axis limits but the plot of all trees is on a different set of axes.

```{r, echo = FALSE, message = FALSE, warning = FALSE}
logbin <- function(x, y = NULL, n) {
  logx <- log10(x)                                           # log transform x value (biomass)
  bin_edges <- seq(min(logx), max(logx), length.out = n + 1) # get edges of bins
  logxbin <- rep(NA, length(logx))                           # create data structure to assign trees to bins
  b <- bin_edges                                             # add a little to the biggest bin temporarily
  b[length(b)] <- b[length(b)] + 1                           # (so that the biggest single tree is put in a bin)
  for (i in 1:length(logx)) {
    logxbin[i] <- sum(logx[i] >= b)                          # assign each tree to a bin
  }
  bin_midpoints <- numeric(n)
  for (i in 1:n) {
    bin_midpoints[i] <- mean(10^(bin_edges[i:(i+1)]))        # backtransform bin edges to linear, and get midpoints
  }
  bin_widths <- diff(10^bin_edges)                           # get linear width of each bin
  bin_factor <- factor(logxbin, levels=1:n)                  # convert bin to factor (required to deal with zeroes if present)
  bin_counts <- table(bin_factor)                            # find number of trees in each bin
  if (!is.null(y)) {
    rawy <- tapply(y, bin_factor, sum)                       # sum y value (production) in each bin
    rawy[is.na(rawy)] <- 0                                   # add zeroes back in if present
    bin_values <- as.numeric(rawy/bin_widths)                # divide production by width for each bin 
  }
  else {
    bin_values <- as.numeric(bin_counts/bin_widths)          # 1-dimensional case.
  }
  
  return(data.frame(bin_midpoint = bin_midpoints,            # return result!
                    bin_value = bin_values,                  # also add bin min and max for bar plot purposes
                    bin_count = as.numeric(bin_counts),
                    bin_min = 10^bin_edges[1:n],
                    bin_max = 10^bin_edges[2:(n+1)]))
  
}

# Function for plotting.

plotlogbin_cutoff <- function(dat, xl, yl, plottitle, plotsubtitle=NULL, reg = FALSE, cutoff = NA, y_min=0.1, y_max=53, x_min=1.1, x_max=141, plotarea=50, y_values=-1:3, x_values = 0:2) {
  
  dat <- transform(dat, bin_value = bin_value/plotarea) # kg per hectare.
  
  p <- ggplot(dat, aes(xmin=bin_min, xmax=bin_max, ymin=0, ymax=bin_value)) + 
    geom_rect(alpha = 0.5) +
    scale_x_log10(name = xl, expand = c(0,0),
                  breaks = 10^x_values,
                  labels = as.character(10^x_values), limits=c(x_min,x_max)) +
    scale_y_log10(name = yl, expand = c(0,0), limits = c(y_min, y_max),
                  breaks = 10^y_values,
                  labels = as.character(10^y_values)) +
    panel_border(colour = 'black') + 
    ggtitle(plottitle, plotsubtitle)
  if (reg) {
    p <- p +
      stat_smooth(method = 'lm', se = FALSE, color = 'forestgreen', size = 2,
                  aes(x = bin_midpoint, y = bin_value)) +
      geom_text(x = -Inf, y = -Inf, 
                label = paste('Slope without cutoff:', 
                              round(lm(I(log10(bin_value)) ~ I(log10(bin_midpoint)), data=dat)$coef[2], 2)),
                hjust = 0, vjust = -1.5)
  
    if (!is.na(cutoff)) {
      p <- p +
        stat_smooth(method = 'lm', se = FALSE, color = 'goldenrod', size = 2,
                    aes(x = bin_midpoint, y = bin_value), data = subset(dat, bin_midpoint <= cutoff)) +
        geom_text(x = -Inf, y = -Inf, 
                  label = paste('Slope with cutoff:', 
                                round(lm(I(log10(bin_value)) ~ I(log10(bin_midpoint)), data=subset(dat, bin_midpoint <= cutoff))$coef[2], 2)),
                  hjust = 0, vjust = -0.2)
    }
  }
  return(p)
}

```


```{r}
# Run binning algorithm.

numbins <- 20 # Can be edited if desired. ***NOT JUST FOR LOOKS***

# Log bins
bci_par_logbin_all <- with(alltreedat, 
                            logbin(x=dbh, y=light_received, n=numbins))
bci_par_logbin_shade <- with(shadedat, 
                              logbin(x=dbh, y=light_received, n=numbins))
bci_par_logbin_inter <- with(intdat, 
                              logbin(x=dbh, y=light_received, n=numbins))
bci_par_logbin_gap <- with(gapdat, 
                            logbin(x=dbh, y=light_received, n=numbins))
```

\newpage

```{r, message = FALSE, echo = FALSE, warning = FALSE, fig.height = 3.5, fig.width = 3.5}
# Determine axis limits
raw_numbers <- c(bci_par_logbin_shade$bin_value, bci_par_logbin_inter$bin_value, bci_par_logbin_gap$bin_value)/50
y_min <- 10^floor(log10(min(raw_numbers)))
y_max <- max(raw_numbers) * 1.1
y_values <- 1:5

xl4 <- 'Diameter (cm)'
yl4 <-expression(paste("Total energy received (W ha"^-1, ")", sep = ""))

ppall <- plotlogbin_cutoff(bci_par_logbin_all, xl4, yl4, 
                           'All species', reg = FALSE, cutoff = NA, y_min = 10, y_max = 1e5, x_max = 250, y_values = y_values)
ppshade <- plotlogbin_cutoff(bci_par_logbin_shade, xl4, yl4,  
                             'Shade-tolerant species', reg = FALSE, cutoff = NA, y_min = y_min, y_max = y_max, x_max = 141, y_values = y_values)
ppint <- plotlogbin_cutoff(bci_par_logbin_inter, xl4, yl4, 
                           'Intermediate species', reg = FALSE, cutoff = NA, y_min = y_min, y_max = y_max, x_max = 141, y_values = y_values)
ppgap <- plotlogbin_cutoff(bci_par_logbin_gap, xl4, yl4, 
                           'Gap species', reg = FALSE, cutoff = NA, y_min = y_min, y_max = y_max, x_max = 141, y_values = y_values)

ppall
ppshade
ppint
ppgap

```

\newpage

# III. 3x3 density scaling by light group vs. shade tolerance group

Here, I only did 10 bins per plot because of the low numbers of individuals especially in the gap specialist/high light group. However, for this plot, the binning is only for visualization purposes and does not enter into the analysis as it does for the energy equivalence plots. This plot was envisioned as a stacked bar plot but since we need to plot the y-axis on a logarithmic scale, this was not possible. It could also be done as a grouped bar plot.

```{r}
# Run binning algorithm for density scaling in the 9 groups.
numbins <- 10 # only for visualizing

shade_lowlight_bin <-  with(subset(shadedat, light_group == 'Low light'), 
                            logbin(x=dbh, y=NULL, n = numbins))
shade_intlight_bin <-  with(subset(shadedat, light_group == 'Intermediate light'), 
                            logbin(x=dbh, y=NULL, n = numbins))
shade_highlight_bin <-  with(subset(shadedat, light_group == 'High light'), 
                             logbin(x=dbh, y=NULL, n = numbins))

int_lowlight_bin <-  with(subset(intdat, light_group == 'Low light'), 
                          logbin(x=dbh, y=NULL, n = numbins))
int_intlight_bin <-  with(subset(intdat, light_group == 'Intermediate light'), 
                          logbin(x=dbh, y=NULL, n = numbins))
int_highlight_bin <-  with(subset(intdat, light_group == 'High light'), 
                           logbin(x=dbh, y=NULL, n = numbins))

gap_lowlight_bin <-  with(subset(gapdat, light_group == 'Low light'), 
                          logbin(x=dbh, y=NULL, n = numbins))
gap_intlight_bin <-  with(subset(gapdat, light_group == 'Intermediate light'), 
                          logbin(x=dbh, y=NULL, n = numbins))
gap_highlight_bin <-  with(subset(gapdat, light_group == 'High light'), 
                           logbin(x=dbh, y=NULL, n = numbins))

```

\newpage

```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.height = 2.5, fig.width = 2.25}
# Determine axis limits
raw_numbers <- c(shade_lowlight_bin$bin_value, shade_intlight_bin$bin_value, shade_highlight_bin$bin_value,
                 int_lowlight_bin$bin_value, int_intlight_bin$bin_value, int_highlight_bin$bin_value,
                 gap_lowlight_bin$bin_value, gap_intlight_bin$bin_value, gap_highlight_bin$bin_value)/50
y_min <- 10^floor(log10(min(raw_numbers)))
y_max <- max(raw_numbers) * 1.1
y_values <- -4:3

xl2 <- 'Diameter (cm)'
yl2 <- expression(paste('Density (individuals ha'^-1,')', sep=''))

th1 <- theme(plot.title = element_text(size = 12), plot.subtitle = element_text(size = 10))

plowshade <- plotlogbin_cutoff(shade_lowlight_bin, xl2, yl2,  
                             'Shade-tolerant spp.', 'Low light', reg = FALSE, cutoff = NA, y_min = y_min, y_max = y_max, x_max = 141, y_values = y_values) 
pintshade <- plotlogbin_cutoff(shade_intlight_bin, xl2, yl2,  
                               'Shade-tolerant spp.', 'Intermediate light', reg = FALSE, cutoff = NA, y_min = y_min, y_max = y_max, x_max = 141, y_values = y_values)
phighshade <- plotlogbin_cutoff(shade_highlight_bin, xl2, yl2,  
                               'Shade-tolerant spp.', 'High light', reg = FALSE, cutoff = NA, y_min = y_min, y_max = y_max, x_max = 141, y_values = y_values) 

plowint <- plotlogbin_cutoff(int_lowlight_bin, xl2, yl2,  
                               'Intermediate spp.', 'Low light', reg = FALSE, cutoff = NA, y_min = y_min, y_max = y_max, x_max = 141, y_values = y_values) 
pintint <- plotlogbin_cutoff(int_intlight_bin, xl2, yl2,  
                               'Intermediate spp.', 'Intermediate light', reg = FALSE, cutoff = NA, y_min = y_min, y_max = y_max, x_max = 141, y_values = y_values) 
phighint <- plotlogbin_cutoff(int_highlight_bin, xl2, yl2,  
                                'Intermediate spp.', 'High light', reg = FALSE, cutoff = NA, y_min = y_min, y_max = y_max, x_max = 141, y_values = y_values) 

plowgap <- plotlogbin_cutoff(gap_lowlight_bin, xl2, yl2,  
                               'Gap spp.', 'Low light', reg = FALSE, cutoff = NA, y_min = y_min, y_max = y_max, x_max = 141, y_values = y_values) 
pintgap <- plotlogbin_cutoff(gap_intlight_bin, xl2, yl2,  
                               'Gap spp.', 'Intermediate light', reg = FALSE, cutoff = NA, y_min = y_min, y_max = y_max, x_max = 141, y_values = y_values) 
phighgap <- plotlogbin_cutoff(gap_highlight_bin, xl2, yl2,  
                                'Gap spp.', 'High light', reg = FALSE, cutoff = NA, y_min = y_min, y_max = y_max, x_max = 141, y_values = y_values) 

phighshade + th1
phighint + th1
phighgap + th1
pintshade + th1
pintint + th1
pintgap + th1
plowshade + th1
plowint + th1
plowgap + th1

```

\newpage

# IV. Density scaling with light received as the scaling variable

This corresponds to the plot that has three regression lines in the fourth panel of the mockup that also has stacked bar plots. For now, I opted to plot the full scaling with visualizations of the underlying bars, to see the result, although later the lines could be put on the same plot. This is more closely corresponding to the diameter scaling plots though, since the methodology is the same as for the diameter scaling but with light instead of diameter as the scaling variable. The hypothesis that the gap trees will have a more positive slope seems to be supported (although it is still negative, it is shallower). As before, the three shade groups are plotted with the same axes.

```{r}
# We need to bin again, this time using light received as the binning variable. 
# The density scaling is thus based on light received, not size.

numbins <- 20 # Only for looks
alltree_par_bin <- with(alltreedat, logbin(x=light_received, y=NULL, n = numbins))
shade_par_bin <-  with(shadedat, logbin(x=light_received, y=NULL, n = numbins))
int_par_bin <- with(intdat, logbin(x=light_received, y=NULL, n = numbins))
gap_par_bin <-  with(gapdat, logbin(x=light_received, y=NULL, n = numbins))
```

\newpage

```{r, message = FALSE, echo = FALSE, warning = FALSE, fig.height = 3.5, fig.width = 3.5}
# Determine axis limits
raw_numbers <- c(shade_par_bin$bin_value, int_par_bin$bin_value, gap_par_bin$bin_value)/50
y_min <- 10^floor(log10(min(raw_numbers)))
y_max <- max(raw_numbers) * 1.1
y_values <- -6:2
x_values <- 1:5

xl5 <- 'Light received (W)'
yl5 <- expression(paste('Density (individuals ha'^-1,')', sep=''))

pparall <- plotlogbin_cutoff(alltree_par_bin, xl5, yl5,  
                               plottitle = 'All species', plotsubtitle = NULL, reg = TRUE, cutoff = NA, y_min = 5e-7, y_max = 30, x_max = 1e6, y_values = y_values, x_values = x_values)
pparshade <- plotlogbin_cutoff(shade_par_bin, xl5, yl5,  
                               plottitle = 'Shade-tolerant species', plotsubtitle = NULL, reg = TRUE, cutoff = NA, y_min = y_min, y_max = y_max, x_max = 4e5, y_values = y_values, x_values = x_values) 
pparint <- plotlogbin_cutoff(int_par_bin, xl5, yl5,  
                               plottitle = 'Intermediate species', plotsubtitle = NULL, reg = TRUE, cutoff = NA, y_min = y_min, y_max = y_max, x_max = 4e5, y_values = y_values, x_values = x_values) 
ppargap <- plotlogbin_cutoff(gap_par_bin, xl5, yl5,  
                             plottitle = 'Gap species', plotsubtitle = NULL, reg = TRUE, cutoff = NA, y_min = y_min, y_max = y_max, x_max = 4e5, y_values = y_values, x_values = x_values) 

pparall
pparshade
pparint
ppargap
```

\newpage
## Hypothesis testing: are the slopes different among shade groups?

```{r, fig.height=3.5, fig.width=3.5}
lmsize_all <- lm(log10(bin_value) ~ log10(bin_midpoint), data=alltreedat)
lmsizecomp_all <- lm(log10(production34) ~ log10(dbh) + log10(light), data=alltreedat)
lmsize_shade <- lm(log10(production34) ~ log10(dbh), data=shadedat)
lmsizecomp_shade <- lm(log10(production34) ~ log10(dbh) + log10(light), data=shadedat)
lmsize_int <- lm(log10(production34) ~ log10(dbh), data=intdat)
lmsizecomp_int <- lm(log10(production34) ~ log10(dbh) + log10(light), data=intdat)
lmsize_gap <- lm(log10(production34) ~ log10(dbh), data=gapdat)
lmsizecomp_gap <- lm(log10(production34) ~ log10(dbh) + log10(light), data=gapdat)

slopedat <- data.frame(withcompidx = rep(c('with light','without light'), each=4),
                       guild = c('all','shade','intermediate','gap'),
                       slope = c(lmsizecomp_all$coef[2], lmsizecomp_shade$coef[2], lmsizecomp_int$coef[2], lmsizecomp_gap$coef[2],
                                 lmsize_all$coef[2], lmsize_shade$coef[2], lmsize_int$coef[2], lmsize_gap$coef[2]),
                       cimin = c(confint(lmsizecomp_all)[2,1], confint(lmsizecomp_shade)[2,1], confint(lmsizecomp_int)[2,1], confint(lmsizecomp_gap)[2,1],
                                 confint(lmsize_all)[2,1], confint(lmsize_shade)[2,1], confint(lmsize_int)[2,1], confint(lmsize_gap)[2,1]),
                       cimax = c(confint(lmsizecomp_all)[2,2], confint(lmsizecomp_shade)[2,2], confint(lmsizecomp_int)[2,2], confint(lmsizecomp_gap)[2,2],
                                 confint(lmsize_all)[2,2], confint(lmsize_shade)[2,2], confint(lmsize_int)[2,2], confint(lmsize_gap)[2,2]))
```

\newpage
```{r, fig.height=3.5, fig.width=3.5}
ggplot(slopedat, aes(x = guild, group = interaction(guild, withcompidx), color = withcompidx, y = slope, ymin = cimin, ymax = cimax)) +
  geom_pointrange() +
  panel_border(colour = 'black') +
  labs(color = 'Regression type') +
  theme(legend.position = 'bottom')
```

## Slope sensitivities to addition of light index

Guild            | Delta
---------------- | ------
All trees        | 0.048
Shade-tolerant   | 0.067
Intermediate     | -0.033
Gap/pioneer      | 0.152
