# More plots using Nadja's modeled relative irradiance values
# QDR 26 Jun 2017

#######################################################################################
# 1. Single plot of total intercepted PAR (y) vs log diameter bins (x).
# Calculate total intercepted PAR by using allometry to get area of each tree's crown and multiply by the % par of each tree.

library(cowplot)
# Use bcicensusdat df generated by the code in the Rmd.

# Function to get tree height and crown dimensions from dbh
# Use same parameters for all trees, taken from Bohlman and O'Brien

tp <- function(dbh) {
  h <- exp(.438 + .595 * log(dbh))    # Height
  cd <- exp(-.157 + .702 * log(dbh))  # Crown depth
  cr <- exp(-.438 + .658 * log(dbh))  # Crown radius
  cV <- exp(-.681 + 2.02 * log(dbh))  # Crown volume
  data.frame(h=h, cd=cd, cr=cr, cV=cV)
}

crowndim <- tp(bcicensusdat$dbh) 
bcicensusdat$crownarea <- pi * crowndim$cr^2
bcicensusdat <- transform(bcicensusdat, light_received = light * crownarea)

# Classification of light into 3 groups.
light_groups <- cut(bcicensusdat$light, breaks = 3)
light_groupcodes <- factor(light_groups, labels = c('Low light','Intermediate light','High light'))

bcicensusdat$light_group <- light_groupcodes

alltreedat <- subset(bcicensusdat, !is.na(dbh) & production34 > 0 & !is.na(light))
shadedat <- subset(bcicensusdat, !is.na(dbh) & production34 > 0 & !is.na(light) & tol_wright == 'S')
intdat <- subset(bcicensusdat, !is.na(dbh) & production34 > 0 & !is.na(light) & tol_wright == 'I')
gapdat <- subset(bcicensusdat, !is.na(dbh) & production34 > 0 & !is.na(light) & tol_wright == 'G')

################
# Run binning algorithm.

numbins <- 20 # Can be edited if desired. ***NOT JUST FOR LOOKS***

# Log bins
bci_par_logbin_all <- with(alltreedat, 
                            logbin(x=dbh, y=light_received, n=numbins))
bci_par_logbin_shade <- with(shadedat, 
                              logbin(x=dbh, y=light_received, n=numbins))
bci_par_logbin_inter <- with(intdat, 
                              logbin(x=dbh, y=light_received, n=numbins))
bci_par_logbin_gap <- with(gapdat, 
                            logbin(x=dbh, y=light_received, n=numbins))

# Energy-equivalence slopes
bci_par_lm_all <- lm(log10(bin_value) ~ log10(bin_midpoint), data = bci_par_logbin_all)
bci_par_lm_shade <- lm(log10(bin_value) ~ log10(bin_midpoint), data = bci_par_logbin_shade)
bci_par_lm_inter <- lm(log10(bin_value) ~ log10(bin_midpoint), data = bci_par_logbin_inter)
bci_par_lm_gap <- lm(log10(bin_value) ~ log10(bin_midpoint), data = bci_par_logbin_gap)

####
# Function for plotting.
plotlogbin_cutoff <- function(dat, xl, yl, plottitle, plotsubtitle=NULL, reg = FALSE, cutoff = NA, y_min=0.1, y_max=53, x_min=1.1, x_max=141, plotarea=50, y_values=-1:3) {
  
  dat <- transform(dat, bin_value = bin_value/plotarea) # kg per hectare.
  
  p <- ggplot(dat, aes(xmin=bin_min, xmax=bin_max, ymin=0, ymax=bin_value)) + 
    geom_rect(alpha = 0.5) +
    scale_x_log10(name = xl, expand = c(0,0),
                  breaks = c(1,10,100),
                  labels = c(1,10,100), limits=c(x_min,x_max)) +
    scale_y_log10(name = yl, expand = c(0,0), limits = c(y_min, y_max),
                  breaks = 10^y_values,
                  labels = as.character(10^y_values)) +
    panel_border(colour = 'black') + 
    ggtitle(plottitle, plotsubtitle) + 
  if (reg) {
    p <- p +
      stat_smooth(method = 'lm', se = FALSE, color = 'forestgreen', size = 2,
                  aes(x = bin_midpoint, y = bin_value)) +
      geom_text(x = -Inf, y = -Inf, 
                label = paste('Slope without cutoff:', 
                              round(lm(I(log10(bin_value)) ~ I(log10(bin_midpoint)), data=dat)$coef[2], 2)),
                hjust = 0, vjust = -1.5)
    if (!is.na(cutoff)) {
      p <- p +
        stat_smooth(method = 'lm', se = FALSE, color = 'goldenrod', size = 2,
                    aes(x = bin_midpoint, y = bin_value), data = subset(dat, bin_midpoint <= cutoff)) +
        geom_text(x = -Inf, y = -Inf, 
                  label = paste('Slope with cutoff:', 
                                round(lm(I(log10(bin_value)) ~ I(log10(bin_midpoint)), data=subset(dat, bin_midpoint <= cutoff))$coef[2], 2)),
                  hjust = 0, vjust = -0.2)
    }
  }
  return(p)
}

# Determine axis limits
raw_numbers <- c(bci_par_logbin_shade$bin_value, bci_par_logbin_inter$bin_value, bci_par_logbin_gap$bin_value)/50
y_min <- 10^floor(log10(min(raw_numbers)))
y_max <- max(raw_numbers) * 1.1
y_values <- c(0.1, 1, 10, 100, 1000)


max(bci_par_logbin_all$bin_value/50)
#y_min <- 10^floor(log10(min(dat$bin_value, na.rm = TRUE)))
#y_max <- max(dat$bin_value, na.rm = TRUE) * 1.1

xl4 <- 'Diameter (cm)'
yl4 <-'Relative energy received per hectare'

ppall <- plotlogbin_cutoff(bci_par_logbin_all, xl4, yl4, 
                           'All species', reg = FALSE, cutoff = NA, y_min = 0.1, y_max = 200, x_max = 250)
ppshade <- plotlogbin_cutoff(bci_par_logbin_shade, xl4, yl4,  
                             'Shade-tolerant species', reg = FALSE, cutoff = NA, y_min = y_min, y_max = y_max, x_max = 141)
ppint <- plotlogbin_cutoff(bci_par_logbin_inter, xl4, yl4, 
                           'Intermediate species', reg = FALSE, cutoff = NA, y_min = y_min, y_max = y_max, x_max = 141)
ppgap <- plotlogbin_cutoff(bci_par_logbin_gap, xl4, yl4, 
                           'Gap species', reg = FALSE, cutoff = NA, y_min = y_min, y_max = y_max, x_max = 141)


#######################################################################################
# 2. 3x3 plot, class light availability into 3 groups (horiz) and shade tolerance groups (vert)
# In each panel, do a density scaling.
# Or do as a 3 panel plot in which there are stacked bars. Each panel is the light group and the stacks are color-coded by the shade tolerance class.

numbins <- 10 # only for visualizing

shade_lowlight_bin <-  with(subset(shadedat, light_group == 'Low light'), logbin(x=dbh, y=NULL, n = numbins))
shade_intlight_bin <-  with(subset(shadedat, light_group == 'Intermediate light'), logbin(x=dbh, y=NULL, n = numbins))
shade_highlight_bin <-  with(subset(shadedat, light_group == 'High light'), logbin(x=dbh, y=NULL, n = numbins))

int_lowlight_bin <-  with(subset(intdat, light_group == 'Low light'), logbin(x=dbh, y=NULL, n = numbins))
int_intlight_bin <-  with(subset(intdat, light_group == 'Intermediate light'), logbin(x=dbh, y=NULL, n = numbins))
int_highlight_bin <-  with(subset(intdat, light_group == 'High light'), logbin(x=dbh, y=NULL, n = numbins))

gap_lowlight_bin <-  with(subset(gapdat, light_group == 'Low light'), logbin(x=dbh, y=NULL, n = numbins))
gap_intlight_bin <-  with(subset(gapdat, light_group == 'Intermediate light'), logbin(x=dbh, y=NULL, n = numbins))
gap_highlight_bin <-  with(subset(gapdat, light_group == 'High light'), logbin(x=dbh, y=NULL, n = numbins))

# Determine axis limits
raw_numbers <- c(shade_lowlight_bin$bin_value, shade_intlight_bin$bin_value, shade_highlight_bin$bin_value,
                 int_lowlight_bin$bin_value, int_intlight_bin$bin_value, int_highlight_bin$bin_value,
                 gap_lowlight_bin$bin_value, gap_intlight_bin$bin_value, gap_highlight_bin$bin_value)/50
y_min <- 10^floor(log10(min(raw_numbers)))
y_max <- max(raw_numbers) * 1.1
y_values <- -4:3

xl2 <- 'Diameter (cm)'
yl2 <- expression(paste('Density (individuals ha'^-1,')', sep=''))

plowshade <- plotlogbin_cutoff(shade_lowlight_bin, xl2, yl2,  
                             'Shade-tolerant species', 'Low light', reg = FALSE, cutoff = NA, y_min = y_min, y_max = y_max, x_max = 141, y_values = y_values) 
pintshade <- plotlogbin_cutoff(shade_intlight_bin, xl2, yl2,  
                               'Shade-tolerant species', 'Intermediate light', reg = FALSE, cutoff = NA, y_min = y_min, y_max = y_max, x_max = 141, y_values = y_values)
phighshade <- plotlogbin_cutoff(shade_highlight_bin, xl2, yl2,  
                               'Shade-tolerant species', 'High light', reg = FALSE, cutoff = NA, y_min = y_min, y_max = y_max, x_max = 141, y_values = y_values) 

plowint <- plotlogbin_cutoff(int_lowlight_bin, xl2, yl2,  
                               'Intermediate species', 'Low light', reg = FALSE, cutoff = NA, y_min = y_min, y_max = y_max, x_max = 141, y_values = y_values) 
pintint <- plotlogbin_cutoff(int_intlight_bin, xl2, yl2,  
                               'Intermediate species', 'Intermediate light', reg = FALSE, cutoff = NA, y_min = y_min, y_max = y_max, x_max = 141, y_values = y_values) 
phighint <- plotlogbin_cutoff(int_highlight_bin, xl2, yl2,  
                                'Intermediate species', 'High light', reg = FALSE, cutoff = NA, y_min = y_min, y_max = y_max, x_max = 141, y_values = y_values) 

plowgap <- plotlogbin_cutoff(gap_lowlight_bin, xl2, yl2,  
                               'gap species', 'Low light', reg = FALSE, cutoff = NA, y_min = y_min, y_max = y_max, x_max = 141, y_values = y_values) 
pintgap <- plotlogbin_cutoff(gap_intlight_bin, xl2, yl2,  
                               'gap species', 'Intermediate light', reg = FALSE, cutoff = NA, y_min = y_min, y_max = y_max, x_max = 141, y_values = y_values) 
phighgap <- plotlogbin_cutoff(gap_highlight_bin, xl2, yl2,  
                                'gap species', 'High light', reg = FALSE, cutoff = NA, y_min = y_min, y_max = y_max, x_max = 141, y_values = y_values) 

p_labels <- expand.grid(c('shade trees', 'int. trees', 'gap trees'), c('high light', 'int. light', 'low light'))
p_labels <- paste(p_labels[,1], p_labels[,2], sep='\n')

nineplots <- plot_grid(phighshade, phighint, phighgap, pintshade, pintint, pintgap, plowshade, plowint, plowgap, align = 'hv', nrow = 3)

#######################################################################################
# 3. Single plot with 3 best-fit lines, one for each shade tolerance group.
# abundance (y) by relative par (x)

# log-log plot as usual

abund_prop_dat <- rbind(transform(bci_par_logbin_shade, proportion = bin_count/sum(bin_count), tolerance = 'shade'),
                        transform(bci_par_logbin_inter, proportion = bin_count/sum(bin_count), tolerance = 'intermediate'),
                        transform(bci_par_logbin_gap, proportion = bin_count/sum(bin_count), tolerance = 'gap'))

ggplot(abund_prop_dat, aes(x = bin_midpoint, y = proportion, group = tolerance, color = tolerance)) +
  geom_point() +
  scale_y_log10(name = 'Diameter (cm)') + scale_x_log10(name = 'Proportion abundance') +
  geom_smooth(method = lm, se = FALSE)
